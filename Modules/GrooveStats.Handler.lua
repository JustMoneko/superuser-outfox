local gs = {}
local path = '/Save/GrooveStats/'

local timeout = 10

-- Reduce the chart to it's smallest unique representable form.
local MinimizeChart = function(chartString)
	local function MinimizeMeasure(measure)
		local minimal = false
		-- We can potentially minimize the chart to get the most compressed
		-- form of the actual chart data.
		-- NOTE(teejusb): This can be more compressed than the data actually
		-- generated by StepMania. This is okay because the charts would still
		-- be considered equivalent.
		-- E.g. 0000                      0000
		--      0000  -- minimized to -->
		--      0000
		--      0000
		--      StepMania will always generate the former since quarter notes are
		--      the smallest quantization.
		while not minimal and #measure % 2 == 0 do
			-- If every other line is all 0s, we can minimize the measure.
			local allZeroes = true
			for i=2, #measure, 2 do
				-- Check if the row is NOT all zeroes (thus we can't minimize).
				if measure[i] ~= string.rep('0', measure[i]:len()) then
					allZeroes = false
					break
				end
			end

			if allZeroes then
				-- To remove every other element while keeping the
				-- indices valid, we iterate from [2, len(t)/2 + 1].
				-- See the example below (where len(t) == 6).

				-- index: 1 2 3 4 5 6  -> remove index 2
				-- value: a b a b a b

				-- index: 1 2 3 4 5    -> remove index 3
				-- value: a a b a b

				-- index: 1 2 3 4      -> remove index 4
				-- value: a a a b

				-- index: 1 2 3
				-- value: a a a
				for i=2, #measure/2+1 do
					table.remove(measure, i)
				end
			else
				minimal = true
			end
		end
	end

	local finalChartData = {}
	local curMeasure = {}
	for line in chartString:gmatch('[^\n]+') do
		-- If we hit a comma, that denotes the end of a measure.
		-- Try to minimize it, and then add it to the final chart data with
		-- the delimiter.
		-- Note: The ending semi-colon has been stripped out.
		if line == ',' then
			MinimizeMeasure(curMeasure)

			for row in ivalues(curMeasure) do
				table.insert(finalChartData, row)
			end
			table.insert(finalChartData, ',')
			-- Just keep removing the first element to clear the table.
			-- This way we don't need to wait for the GC to cleanup the unused values.
			for i=1, #curMeasure do
				table.remove(curMeasure, 1)
			end
		else
			table.insert(curMeasure, line)
		end
	end

	-- Add the final measure.
	if #curMeasure > 0 then
		MinimizeMeasure(curMeasure)

		for row in ivalues(curMeasure) do
			table.insert(finalChartData, row)
		end
	end

	return table.concat(finalChartData, '\n')
end

local NormalizeFloatDigits = function(param)
	local function NormalizeDecimal(decimal)
		-- Remove any control characters from the string to prevent conversion failures.
		decimal = decimal:gsub("%c", "")
		local rounded = tonumber(decimal)

		-- Round to 3 decimal places
		local mult = 10^3
		rounded = (rounded * mult + 0.5 - (rounded * mult + 0.5) % 1) / mult
		return string.format("%.3f", rounded)
	end

	local paramParts = {}
	for beat_bpm in param:gmatch('[^,]+') do
		local beat, bpm = beat_bpm:match('(.+)=(.+)')
		table.insert(paramParts, NormalizeDecimal(beat) .. '=' .. NormalizeDecimal(bpm))
	end
	return table.concat(paramParts, ',')
end

local function GSPrefs(plr)
	local ret = {}
	local pn = PlayerNumber:Reverse()[plr] + 1
	local path = PROFILEMAN:GetProfileDir(ProfileSlot[pn])
	if not path then return ret end
	local data = IniFile.ReadFile(path..'GrooveStats.ini')
	if not data or not data.GrooveStats then return ret end
	return data.GrooveStats
end

function gs.GetAPI(plr)
	local gsData = GSPrefs(plr)
	return gsData.ApiKey
end

function gs.IsPadPlayer(plr)
	local ret = false
	local gsData = GSPrefs(plr)
	if gsData.IsPadPlayer then
		ret = (tonumber(gsData.IsPadPlayer) == 1 and true) or false
	end
	return ret
end

function gs.timeout(s)
	if not s then return timeout end
	timeout = s
end

function gs.ChartHash(plr)
	local song = GAMESTATE:GetCurrentSong()
	local filepath = song:GetSongFilePath()
	local filetype = filepath:sub(1 - filepath:reverse():find('%.'))
	local chart = GAMESTATE:GetCurrentSteps(plr)
	local bpmtable = chart:GetTimingData():GetBPMsAndTimes()
	local bpms = NormalizeFloatDigits(table.concat(bpmtable, ','))
	local stepstype = ToEnumShortString(chart:GetStepsType()):lower()
	local diff = ToEnumShortString(chart:GetDifficulty()):lower()
	local desc = chart:GetDescription()
	local data = File.Read(filepath)
	local ndstring
	if filetype == 'ssc' then
		for nd in data:gmatch('#NOTEDATA.-#NOTES2?:[^;]*') do
			nd = nd:gsub('\r\n?', '\n')
			local nd_stepstype, nd_diff, nd_desc = '', '', ''
			for st in nd:gmatch('#STEPSTYPE:(.-);') do
				if nd_stepstype == '' and st ~= '' then
					nd_stepstype = st:gsub('%-', '_'):lower()
					break
				end
			end
			for d in nd:gmatch('#DIFFICULTY:(.-);') do
				if nd_diff == '' and d ~= '' then
					nd_diff = d:lower()
					break
				end
			end
			for d in nd:gmatch('#DESCRIPTION:(.-);') do
				if nd_desc == '' and d ~= '' then
					nd_desc = d
					break
				end
			end
			if (stepstype == nd_stepstype and diff == nd_diff) then
				if (nd_diff ~= 'edit' or nd_desc == desc) then
					ndstring = nd:match("#NOTES2?:[\n]*([^;]*)\n?$"):gsub("//[^\n]*", ""):gsub('[\r\t\f\v ]+', '')
				end
			end
		end
	elseif filetype == 'sm' then
		for nd in data:gmatch('#NOTES2?[^;]*') do
			nd = nd:gsub('\r\n?', '\n')
			local parts = {}
			for part in nd:gmatch('[^:]+') do
				table.insert(parts, part)
			end
			if #parts >= 7 then
				local nd_stepstype = parts[2]:gsub('[^%w-]', ''):gsub('%-', '_'):lower()
				local nd_diff = ToEnumShortString(OldStyleStringToDifficulty(parts[4]:gsub('[^%w]', ''))):lower()
				local nd_desc = parts[3]:gsub('^%s*(.-)', '')
				if (stepstype == nd_stepstype and diff == nd_diff) then
					if (nd_diff ~= 'edit' or nd_desc == desc) then
						ndstring = parts[7]:gsub("//[^\n]*", ""):gsub('[\r\t\f\v ]+', '')
					end
				end
			end
		end
	else
		return
	end
	if ndstring and bpms then
		local hash = CRYPTMAN:SHA1String(MinimizeChart(ndstring)..NormalizeFloatDigits(bpms))
		local bytes = {}
		for i = 1, string.len(hash), 1 do
			table.insert(bytes, string.format('%02x', string.byte(hash, i)))
		end
		return table.concat(bytes, ''):sub(1, 16)
	else
		return
	end
end

function gs.request(type, data)
	local id = CRYPTMAN:GenerateRandomUUID()
	local now = GetTimeSinceStart()
	local time = 0
	local timeout = gs.timeout()
	if type == 'ping' then
		id = type
		data = {
			action = 'ping',
			protocol = 1,
		}
	end
	local req = coroutine.create(function(d)
		File.Write(path..'requests/'..id..'.json', JsonEncode(d))
		while true do
			time = time + (GetTimeSinceStart() - now)
			now = GetTimeSinceStart()
			local res = File.Read(path..'responses/'..id..'.json')
			if res then
				coroutine.yield(JsonDecode(res))
				break
			end
			if time > timeout then
				res = {
					status = 'timeout',
					data = {}
				}
				coroutine.yield(res)
				break
			end
		end
	end)
	local s, ret = coroutine.resume(req, data)
	MESSAGEMAN:Broadcast(type, ret)
	return ret
end

function gs.ping()
	return gs.request('Ping', {
		action = 'ping',
		protocol = 1,
	})
end
function gs.session()
	return gs.request('Session', {
		action = 'groovestats/new-session',
		chartHashVersion = 3
	})
end
function gs.scores(data)
	data.action = 'groovestats/player-scores'
	return gs.request('PlayerScores', data)
end
function gs.leaderboards(data)
	data.action = 'groovestats/player-leaderboards'
	return gs.request('PlayerLeaderboards', data)
end
function gs.submit(data)
	data.action = 'groovestats/score-submit'
	return gs.request('ScoreSubmit', data)
end

return gs
